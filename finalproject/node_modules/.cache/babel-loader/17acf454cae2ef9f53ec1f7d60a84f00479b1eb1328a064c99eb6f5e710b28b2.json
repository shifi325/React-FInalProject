{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport { postOrderA, getOrderByIdA, getOrdersA } from './OrderApi';\nconst initialState = {\n  arrOrders: [],\n  cart: [],\n  price: 0\n};\nexport const addOrder = createAsyncThunk('order', async (order, thunkAPI) => {\n  const res = await postOrderA(order);\n  return res;\n});\nexport const getOrderById = createAsyncThunk('order', async (id, thunkAPI) => {\n  const res = await getOrderByIdA(id);\n  return res;\n});\nexport const getAllOrders = createAsyncThunk('order', async thunkAPI => {\n  const res = await getOrdersA();\n  return res;\n});\nexport const orderSlice = createSlice({\n  name: 'order',\n  initialState,\n  reducers: {\n    addToShoppingCart: (state, action) => {\n      const existingProduct = state.cart.find(item => item.p.id === action.payload.p.id);\n      if (existingProduct) {\n        existingProduct.quantity += action.payload.quantity;\n      } else {\n        state.cart = [...state.cart, action.payload];\n      }\n      state.price += action.payload.quantity * action.payload.p.price;\n    },\n    removeFromShoppingCart: (state, action) => {\n      const productToRemove = state.cart.find(item => item.p.id === action.payload.p.id);\n      if (productToRemove) {\n        state.cart = state.cart.filter(item => item !== productToRemove);\n        state.price -= productToRemove.quantity * productToRemove.p.price;\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(addOrder.fulfilled, (state, {\n      payload\n    }) => {\n      state.arrOrders = payload;\n      state.status = \"\";\n    });\n\n    // You can chain calls, or have separate `builder.addCase()` lines each time\n    // .addCase(fetchAllPost.pending, (state, action) => {\n    //     state.status = \"pending\"\n    // })\n    // .addCase(fetchAllPost.rejected, (state, action) => {\n    //     state.status = \"failed!!\"\n    // })\n    // .addCase(deleteOnePost.fulfilled, (state, action) => {\n    //     let index = state.arrProduct.findIndex(x => x.id === action.payload)\n    //     state.arrProduct.splice(index, 1)\n    //     state.statusDelete = \"deleted\"\n    // })\n    // .addCase(deleteOnePost.rejected, (state, action) => {\n    //     state.statusDelete = \"failded delete\"\n    // })\n  }\n});\nexport const {\n  addToShoppingCart,\n  removeFromShoppingCart\n} = orderSlice.actions;\nexport default orderSlice.reducer;","map":{"version":3,"names":["createAsyncThunk","createSlice","postOrderA","getOrderByIdA","getOrdersA","initialState","arrOrders","cart","price","addOrder","order","thunkAPI","res","getOrderById","id","getAllOrders","orderSlice","name","reducers","addToShoppingCart","state","action","existingProduct","find","item","p","payload","quantity","removeFromShoppingCart","productToRemove","filter","extraReducers","builder","addCase","fulfilled","status","actions","reducer"],"sources":["C:/Users/שיפי וינגרטן/Pictures/Saved Pictures/סמינר/כיתה יד/תכנות/react/פרויקט/finalproject/src/components/features/Order/OrderSlice.js"],"sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\r\nimport { postOrderA, getOrderByIdA, getOrdersA } from './OrderApi'\r\nconst initialState = {\r\n    arrOrders: [],\r\n    cart: [],\r\n    price: 0\r\n}\r\n\r\nexport const addOrder = createAsyncThunk(\r\n    'order',\r\n    async (order, thunkAPI) => {\r\n        const res = await postOrderA(order)\r\n        return res\r\n    },\r\n)\r\n\r\nexport const getOrderById = createAsyncThunk(\r\n    'order',\r\n    async (id, thunkAPI) => {\r\n        const res = await getOrderByIdA(id)\r\n        return res\r\n    },\r\n)\r\n\r\nexport const getAllOrders = createAsyncThunk(\r\n    'order',\r\n    async (thunkAPI) => {\r\n        const res = await getOrdersA()\r\n        return res\r\n    },\r\n)\r\n\r\nexport const orderSlice = createSlice({\r\n    name: 'order',\r\n    initialState,\r\n    reducers: {\r\n        addToShoppingCart: (state, action) => {\r\n            const existingProduct = state.cart.find(item => item.p.id === action.payload.p.id);\r\n            if (existingProduct) {\r\n                existingProduct.quantity += action.payload.quantity\r\n            } else {\r\n                state.cart = [...state.cart, action.payload]\r\n            }\r\n            state.price += action.payload.quantity * action.payload.p.price\r\n\r\n        },\r\n        removeFromShoppingCart: (state, action) => {\r\n            const productToRemove = state.cart.find(item => item.p.id === action.payload.p.id);\r\n            if (productToRemove) {\r\n                state.cart = state.cart.filter(item => item !== productToRemove);\r\n                state.price -= productToRemove.quantity * productToRemove.p.price;\r\n            }\r\n    }},\r\n    \r\n        extraReducers: (builder) => {\r\n            builder\r\n                .addCase(addOrder.fulfilled, (state, { payload }) => {\r\n                    state.arrOrders = payload\r\n                    state.status = \"\"\r\n                })\r\n\r\n            // You can chain calls, or have separate `builder.addCase()` lines each time\r\n            // .addCase(fetchAllPost.pending, (state, action) => {\r\n            //     state.status = \"pending\"\r\n            // })\r\n            // .addCase(fetchAllPost.rejected, (state, action) => {\r\n            //     state.status = \"failed!!\"\r\n            // })\r\n            // .addCase(deleteOnePost.fulfilled, (state, action) => {\r\n            //     let index = state.arrProduct.findIndex(x => x.id === action.payload)\r\n            //     state.arrProduct.splice(index, 1)\r\n            //     state.statusDelete = \"deleted\"\r\n            // })\r\n            // .addCase(deleteOnePost.rejected, (state, action) => {\r\n            //     state.statusDelete = \"failded delete\"\r\n            // })\r\n        },\r\n\r\n    })\r\nexport const { addToShoppingCart ,removeFromShoppingCart} = orderSlice.actions\r\n\r\nexport default orderSlice.reducer"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}